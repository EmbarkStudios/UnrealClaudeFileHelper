<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Unreal Index — Dashboard</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: 'Segoe UI', system-ui, sans-serif; background: #1e1e1e; color: #d4d4d4; padding: 20px; max-width: 1200px; margin: 0 auto; }
    h2 { font-size: 1.1em; color: #9cdcfe; margin-bottom: 12px; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 24px; }
    .card { background: #252526; border: 1px solid #3e3e3e; border-radius: 6px; padding: 16px; }
    .card-full { grid-column: 1 / -1; }
    .stat-row { display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid #2d2d2d; font-size: 13px; }
    .stat-row:last-child { border-bottom: none; }
    .stat-label { color: #808080; }
    .stat-value { color: #4ec9b0; font-family: 'Cascadia Code', 'Consolas', monospace; }
    table { width: 100%; border-collapse: collapse; font-size: 13px; }
    th { text-align: left; color: #808080; padding: 6px 8px; border-bottom: 1px solid #3e3e3e; }
    td { padding: 6px 8px; border-bottom: 1px solid #2d2d2d; }
    td.mono { font-family: 'Cascadia Code', 'Consolas', monospace; font-size: 12px; }
    .health-ok { color: #4ec9b0; }
    .health-warn { color: #ce9178; }
    .health-err { color: #f44747; }
    .loading { color: #808080; font-style: italic; }
    .error { color: #f44747; }
    .refresh-btn { background: #333; color: #808080; border: 1px solid #3e3e3e; padding: 4px 12px; border-radius: 3px; cursor: pointer; font-size: 12px; }
    .refresh-btn:hover { background: #3e3e3e; color: #d4d4d4; }
    .version-alert { background: #2a2218; border: 1px solid #ce9178; border-radius: 6px; padding: 14px 16px; margin-bottom: 16px; display: none; }
    .version-alert.visible { display: block; }
    .version-alert-header { display: flex; align-items: center; gap: 12px; font-size: 13px; position: relative; }
    .version-alert-dismiss { position: absolute; right: 0; top: -4px; background: none; border: none; color: #ce9178; font-size: 18px; cursor: pointer; padding: 4px 8px; line-height: 1; opacity: 0.7; }
    .version-alert-dismiss:hover { opacity: 1; }
    .version-alert-header .label { color: #ce9178; font-weight: 600; }
    .version-alert-header .hashes { color: #d4d4d4; font-family: 'Cascadia Code','Consolas',monospace; font-size: 12px; }
    .version-alert-actions { margin-top: 10px; display: flex; align-items: center; gap: 12px; }
    .btn-primary { padding: 6px 16px; background: #0e639c; color: #fff; border: none; border-radius: 3px; cursor: pointer; font-size: 12px; }
    .btn-primary:hover { background: #1177bb; }
    .btn-primary:disabled { background: #333; color: #666; cursor: default; }
    .version-alert-status { font-size: 12px; color: #808080; }
    .overview-bar { display: flex; gap: 16px; margin-bottom: 20px; }
    .overview-item { flex: 1; background: #252526; border: 1px solid #3e3e3e; border-radius: 6px; padding: 14px 16px; display: flex; align-items: center; gap: 12px; }
    .overview-dot { width: 12px; height: 12px; border-radius: 50%; flex-shrink: 0; }
    .dot-green { background: #4ec9b0; box-shadow: 0 0 6px #4ec9b044; }
    .dot-red { background: #f44747; box-shadow: 0 0 6px #f4474744; }
    .dot-yellow { background: #ce9178; box-shadow: 0 0 6px #ce917844; }
    .dot-gray { background: #555; }
    .overview-info { flex: 1; min-width: 0; }
    .overview-name { font-size: 13px; font-weight: 600; color: #d4d4d4; }
    .overview-detail { font-size: 11px; color: #808080; margin-top: 2px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .overview-action { flex-shrink: 0; }
    .action-btn { padding: 4px 12px; background: #0e639c; color: #fff; border: none; border-radius: 3px; cursor: pointer; font-size: 11px; }
    .action-btn:hover { background: #1177bb; }
    .action-btn:disabled { background: #333; color: #666; cursor: default; }
    .action-btn-warn { background: #6d4c1d; }
    .action-btn-warn:hover { background: #8a6020; }
    .cmd-panel { background: #1a1a2e; border: 1px solid #3e3e3e; border-radius: 6px; padding: 12px 16px; margin-bottom: 20px; display: none; }
    .cmd-panel.visible { display: block; }
    .cmd-panel h3 { font-size: 12px; color: #569cd6; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px; }
    .cmd-row { display: flex; align-items: center; gap: 12px; margin-bottom: 6px; font-size: 12px; }
    .cmd-row:last-child { margin-bottom: 0; }
    .cmd-label { color: #808080; width: 120px; flex-shrink: 0; }
    .cmd-code { background: #2d2d2d; padding: 4px 8px; border-radius: 3px; font-family: 'Cascadia Code', 'Consolas', monospace; color: #ce9178; flex: 1; overflow-x: auto; white-space: nowrap; cursor: pointer; }
    .cmd-code:hover { background: #3e3e3e; }
    .cmd-toggle { background: none; border: 1px solid #3e3e3e; color: #808080; padding: 4px 10px; border-radius: 3px; cursor: pointer; font-size: 11px; }
    .cmd-toggle:hover { color: #d4d4d4; border-color: #569cd6; }
  </style>
</head>
<body>
  <script src="/dashboard.js"></script>

  <!-- Toolbar -->
  <div style="display:flex;align-items:center;gap:12px;margin-bottom:12px">
    <button class="refresh-btn" onclick="loadAllWithOverview()">Refresh</button>
    <button class="cmd-toggle" onclick="toggleCmds()" id="cmd-toggle-btn">Show Commands</button>
    <span id="version-badge" style="margin-left:auto;font-size:11px;color:#555;font-family:'Cascadia Code','Consolas',monospace"></span>
  </div>

  <!-- Quick Commands (toggle) -->
  <div class="cmd-panel" id="cmd-panel">
    <h3>Quick Commands (click to copy)</h3>
    <div class="cmd-row"><span class="cmd-label">Start containers</span><code class="cmd-code" onclick="copyCmd(this)">wsl -- bash -c 'cd ~/.claude/repos/unreal-index && docker compose up -d'</code></div>
    <div class="cmd-row"><span class="cmd-label">Stop containers</span><code class="cmd-code" onclick="copyCmd(this)">wsl -- bash -c 'cd ~/.claude/repos/unreal-index && docker compose stop'</code></div>
    <div class="cmd-row"><span class="cmd-label">Container logs</span><code class="cmd-code" onclick="copyCmd(this)">wsl -- bash -c 'cd ~/.claude/repos/unreal-index && docker compose logs -f --tail 50'</code></div>
    <div class="cmd-row"><span class="cmd-label">Start watcher</span><code class="cmd-code" onclick="copyCmd(this)">node "%USERPROFILE%\.claude\repos\unreal-index\src\watcher\watcher-client.js" --workspace main</code></div>
    <div class="cmd-row"><span class="cmd-label">Run setup</span><code class="cmd-code" onclick="copyCmd(this)">node "%USERPROFILE%\.claude\repos\unreal-index\src\setup-gui.js"</code></div>
  </div>

  <!-- System Overview -->
  <div class="overview-bar" id="system-overview">
    <div class="overview-item" id="ov-service">
      <div class="overview-dot dot-gray" id="ov-service-dot"></div>
      <div class="overview-info">
        <div class="overview-name">Service</div>
        <div class="overview-detail" id="ov-service-detail">Checking...</div>
      </div>
      <div class="overview-action" id="ov-service-action"></div>
    </div>
    <div class="overview-item" id="ov-watcher">
      <div class="overview-dot dot-gray" id="ov-watcher-dot"></div>
      <div class="overview-info">
        <div class="overview-name">Watcher</div>
        <div class="overview-detail" id="ov-watcher-detail">Checking...</div>
      </div>
      <div class="overview-action" id="ov-watcher-action"></div>
    </div>
    <div class="overview-item" id="ov-zoekt">
      <div class="overview-dot dot-gray" id="ov-zoekt-dot"></div>
      <div class="overview-info">
        <div class="overview-name">Zoekt</div>
        <div class="overview-detail" id="ov-zoekt-detail">Checking...</div>
      </div>
      <div class="overview-action" id="ov-zoekt-action"></div>
    </div>
  </div>

  <!-- Version Mismatch Alert -->
  <div class="version-alert" id="version-alert">
    <div class="version-alert-header">
      <span class="label">Version mismatch</span>
      <span class="hashes" id="version-alert-hashes"></span>
      <button class="version-alert-dismiss" onclick="document.getElementById('version-alert').classList.remove('visible')" title="Dismiss">&times;</button>
    </div>
    <div class="version-alert-actions" id="version-alert-actions"></div>
  </div>

  <div class="grid">
    <!-- Projects -->
    <div class="card card-full">
      <h2 style="display:flex;align-items:center;gap:12px">Projects
        <button class="action-btn" onclick="toggleConfigEdit()" id="config-edit-btn" style="margin-left:auto">Edit Config</button>
      </h2>
      <div id="config-view">
        <div id="projects-table" class="loading">Loading...</div>
      </div>
      <div id="config-editor" style="display:none">
        <textarea id="config-textarea" style="width:100%;height:300px;background:#1e1e1e;color:#d4d4d4;border:1px solid #3e3e3e;border-radius:4px;padding:8px;font-family:'Cascadia Code','Consolas',monospace;font-size:12px;resize:vertical;tab-size:2"></textarea>
        <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
          <button class="btn-primary" onclick="saveConfig()">Save</button>
          <button class="refresh-btn" onclick="toggleConfigEdit()">Cancel</button>
          <span id="config-save-status" style="font-size:12px;color:#808080"></span>
        </div>
      </div>
    </div>

    <!-- Index Stats + Service Health -->
    <div class="card">
      <h2>Index Stats</h2>
      <div id="index-stats" class="loading">Loading...</div>
    </div>

    <div class="card">
      <h2>Service Health</h2>
      <div id="health" class="loading">Loading...</div>
    </div>

    <!-- Watcher Status -->
    <div class="card card-full">
      <h2>Watcher Status</h2>
      <div id="watcher" class="loading">Loading...</div>
    </div>
  </div>

  <script>
    function toggleCmds() {
      const panel = document.getElementById('cmd-panel');
      const btn = document.getElementById('cmd-toggle-btn');
      panel.classList.toggle('visible');
      btn.textContent = panel.classList.contains('visible') ? 'Hide Commands' : 'Show Commands';
    }

    function copyCmd(el) {
      const text = el.textContent;
      navigator.clipboard.writeText(text).then(() => {
        const orig = el.textContent;
        el.textContent = 'Copied!';
        el.style.color = '#4ec9b0';
        setTimeout(() => { el.textContent = orig; el.style.color = ''; }, 1500);
      });
    }

    async function startWatcher() {
      const btn = document.getElementById('start-watcher-btn');
      const msg = document.getElementById('start-watcher-msg');
      if (btn) btn.disabled = true;
      if (msg) msg.textContent = 'Starting...';
      try {
        const resp = await fetch('/api/watcher/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ workspace: WorkspaceContext.active })
        });
        const data = await resp.json();
        if (!resp.ok) {
          if (msg) msg.textContent = data.error || 'Failed to start';
          if (btn) btn.disabled = false;
          return;
        }
        if (msg) msg.textContent = 'Started! Waiting for heartbeat...';
        let attempts = 0;
        const poll = setInterval(async () => {
          attempts++;
          try {
            const sr = await WorkspaceContext.serviceFetch('/watcher-status');
            const sd = await sr.json();
            if (sd.hasActiveWatcher) {
              clearInterval(poll);
              loadWatcher();
            }
          } catch {}
          if (attempts >= 30) {
            clearInterval(poll);
            if (msg) msg.textContent = 'Started but still reconciling — refresh shortly';
            if (btn) btn.disabled = false;
          }
        }, 2000);
      } catch (err) {
        if (msg) msg.textContent = err.name === 'TypeError'
          ? 'Setup GUI not reachable. Ensure you are on port 3846.'
          : 'Error: ' + err.message;
        if (btn) btn.disabled = false;
      }
    }

    async function loadIndexStats() {
      const el = document.getElementById('index-stats');
      try {
        // Use /health endpoint only — it has memoryIndex counts already loaded in-memory (sub-ms)
        // Avoid /internal/status which does live COUNT(*) queries (~700ms)
        const resp = await WorkspaceContext.serviceFetch('/health');
        const health = await resp.json();
        const mi = health.memoryIndex || {};
        el.innerHTML = `
          <div class="stat-row"><span class="stat-label">Total indexed</span><span class="stat-value">${(mi.files || 0).toLocaleString()} files</span></div>
          <div class="stat-row"><span class="stat-label">Types</span><span class="stat-value">${(mi.types || 0).toLocaleString()}</span></div>
          <div class="stat-row"><span class="stat-label">Members</span><span class="stat-value">${(mi.members || 0).toLocaleString()}</span></div>
          <div class="stat-row"><span class="stat-label">Assets</span><span class="stat-value">${(mi.assets || 0).toLocaleString()}</span></div>
          <div class="stat-row"><span class="stat-label">Zoekt shards</span><span class="stat-value">${health.zoekt?.shardCount ?? '\u2014'}</span></div>
          <div class="stat-row"><span class="stat-label">Query mode</span><span class="stat-value health-ok">${health.queryMode || 'unknown'}</span></div>
        `;
      } catch (err) {
        el.innerHTML = `<span class="error">Failed to load: ${esc(err.message)}</span>`;
      }
    }

    async function loadWatcher() {
      const watcherEl = document.getElementById('watcher');
      try {
        const resp = await WorkspaceContext.serviceFetch('/watcher-status');
        const data = await resp.json();
        const active = data.hasActiveWatcher;
        const activeWatchers = (data.watchers || []).filter(x => x.status === 'active');
        const w = activeWatchers.sort((a, b) =>
          (b.counters?.filesIngested || 0) - (a.counters?.filesIngested || 0)
        )[0];

        if (w) {
          const uptime = w.startedAt ? formatRelative(w.startedAt) : '\u2014';
          const lastIngest = w.counters?.lastIngestAt ? formatRelative(w.counters.lastIngestAt) : 'never';
          const nextReconcile = w.reconciliation?.nextRunAt ? formatRelative(w.reconciliation.nextRunAt, true) : '\u2014';
          const wGit = w.gitHash || '\u2014';
          const wLastIngestAgo = data.lastIngestAt ? Date.now() - new Date(data.lastIngestAt).getTime() : Infinity;
          const wIsIngesting = wLastIngestAgo < 15000;
          const statusLabel = wIsIngesting ? 'ingesting' : (active ? 'active' : 'inactive');
          const statusClass = wIsIngesting ? 'health-warn' : (active ? 'health-ok' : 'health-err');
          watcherEl.innerHTML = `
            <div class="stat-row">
              <span class="stat-label">Status</span>
              <span class="stat-value ${statusClass}">${statusLabel}</span>
            </div>
            <div class="stat-row"><span class="stat-label">Version</span><span class="stat-value">${esc(w.version || '\u2014')} (${esc(wGit)})</span></div>
            <div class="stat-row"><span class="stat-label">Started</span><span class="stat-value">${uptime}</span></div>
            <div class="stat-row"><span class="stat-label">Session files</span><span class="stat-value">${(w.counters?.filesIngested || 0).toLocaleString()}</span></div>
            <div class="stat-row"><span class="stat-label">Session assets</span><span class="stat-value">${(w.counters?.assetsIngested || 0).toLocaleString()}</span></div>
            <div class="stat-row"><span class="stat-label">Errors</span><span class="stat-value ${w.counters?.errorsCount > 0 ? 'health-warn' : ''}">${w.counters?.errorsCount || 0}</span></div>
            <div class="stat-row"><span class="stat-label">Last ingest</span><span class="stat-value">${lastIngest}</span></div>
            <div class="stat-row"><span class="stat-label">Next reconcile</span><span class="stat-value">${nextReconcile}</span></div>
            ${data.watchers.filter(x => x.status === 'active').length > 1 ? `<div class="stat-row"><span class="stat-label health-warn">Warning</span><span class="stat-value health-warn">${data.watchers.filter(x => x.status === 'active').length} watchers connected</span></div>` : ''}
          `;
        } else {
          watcherEl.innerHTML = `
            <div class="stat-row">
              <span class="stat-label">Status</span>
              <span class="stat-value health-err">no watcher connected</span>
            </div>
            <div style="margin-top:12px;display:flex;align-items:center;gap:12px">
              <button onclick="startWatcher()" id="start-watcher-btn"
                style="padding:6px 16px;background:#0e639c;color:#fff;border:none;border-radius:4px;cursor:pointer;font-size:13px">
                Start Watcher
              </button>
              <span id="start-watcher-msg" style="font-size:12px;color:#808080"></span>
            </div>
          `;
        }
      } catch (err) {
        watcherEl.innerHTML = `<span class="error">Failed to load: ${esc(err.message)}</span>`;
      }
    }

    async function loadHealth() {
      const el = document.getElementById('health');
      try {
        const resp = await WorkspaceContext.serviceFetch('/health');
        const data = await resp.json();

        const zoekt = data.zoekt || {};
        const zoektStatus = (zoekt.running || zoekt.available) ? 'running' : 'stopped';
        const zoektClass = (zoekt.running || zoekt.available) ? 'health-ok' : 'health-err';

        // Update version badge
        const vBadge = document.getElementById('version-badge');
        if (vBadge) vBadge.textContent = `v${data.version || '?'} (${data.gitHash || '?'})`;

        el.innerHTML = `
          <div class="stat-row"><span class="stat-label">Status</span><span class="stat-value health-ok">${data.status}</span></div>
          <div class="stat-row"><span class="stat-label">Uptime</span><span class="stat-value">${formatUptime(data.uptimeSeconds)}</span></div>
          <div class="stat-row"><span class="stat-label">Node.js RSS</span><span class="stat-value">${(data.memoryMB.rss / 1024).toFixed(1)} GB</span></div>
          <div class="stat-row"><span class="stat-label">Heap</span><span class="stat-value">${data.memoryMB.heapUsed} / ${data.memoryMB.heapTotal} MB</span></div>
          ${data.docker ? (() => {
            const d = data.docker;
            const rssGB = (data.memoryMB.rss / 1024).toFixed(1);
            const limitGB = (d.memLimitMB / 1024).toFixed(1);
            const rssPct = Math.round(data.memoryMB.rss / d.memLimitMB * 100);
            const cls = rssPct > 85 ? 'health-err' : rssPct > 70 ? 'health-warn' : 'health-ok';
            return '<div class="stat-row"><span class="stat-label">Container limit</span><span class="stat-value ' + cls + '">' + rssGB + ' / ' + limitGB + ' GB (' + rssPct + '%)</span></div>';
          })() : ''}
          <div class="stat-row"><span class="stat-label">Zoekt</span><span class="stat-value ${zoektClass}">${zoektStatus}${zoekt.shardCount != null ? ' (' + zoekt.shardCount + ' shards)' : ''}</span></div>
        `;
      } catch (err) {
        el.innerHTML = `<span class="error">Failed to load: ${esc(err.message)}</span>`;
      }
    }

    async function loadOverview() {
      const serviceDot = document.getElementById('ov-service-dot');
      const serviceDetail = document.getElementById('ov-service-detail');
      const watcherDot = document.getElementById('ov-watcher-dot');
      const watcherDetail = document.getElementById('ov-watcher-detail');
      const watcherAction = document.getElementById('ov-watcher-action');
      const zoektDot = document.getElementById('ov-zoekt-dot');
      const zoektDetail = document.getElementById('ov-zoekt-detail');
      const zoektAction = document.getElementById('ov-zoekt-action');
      const versionAlert = document.getElementById('version-alert');
      const serviceAction = document.getElementById('ov-service-action');

      if (!WorkspaceContext.active) {
        serviceDot.className = 'overview-dot dot-gray';
        serviceDetail.textContent = 'No workspace selected';
        return;
      }

      let serviceGitHash = null;
      let watcherGitHash = null;
      let healthData = null;

      // Fetch health + watcher status in parallel (single call each)
      const [healthResult, watcherResult] = await Promise.allSettled([
        WorkspaceContext.serviceFetch('/health').then(r => r.json()),
        WorkspaceContext.serviceFetch('/watcher-status').then(r => r.json()),
      ]);

      // Service health
      if (healthResult.status === 'fulfilled') {
        healthData = healthResult.value;
        serviceGitHash = healthData.gitHash || null;
        const hash = healthData.gitHash ? ` \u00b7 ${healthData.gitHash}` : '';
        const heap = healthData.memoryMB.heapUsed;
        const heapMax = healthData.memoryMB.heapTotal;
        const heapPct = Math.round(heap / heapMax * 100);
        if (heap > 2800) {
          serviceDot.className = 'overview-dot dot-yellow';
          serviceDetail.textContent = `Up ${formatUptime(healthData.uptimeSeconds)}${hash} \u00b7 Heap ${heap}/${heapMax} MB \u2014 high memory`;
        } else {
          serviceDot.className = 'overview-dot dot-green';
          serviceDetail.textContent = `Up ${formatUptime(healthData.uptimeSeconds)}${hash} \u00b7 ${healthData.memoryMB.rss} MB RSS \u00b7 Heap ${heapPct}%`;
        }
        serviceAction.innerHTML = '<button class="action-btn action-btn-warn" onclick="overviewRestartService(this)">Restart</button>';
      } else {
        serviceDot.className = 'overview-dot dot-red';
        serviceDetail.innerHTML = 'Not responding \u2014 restart with: <code>docker compose up -d</code>';
        serviceAction.innerHTML = '';
      }

      // Watcher status
      if (watcherResult.status === 'fulfilled') {
        const data = watcherResult.value;
        const active = data.hasActiveWatcher;
        const activeWatchers = (data.watchers || []).filter(x => x.status === 'active');
        const w = activeWatchers.sort((a, b) =>
          (b.counters?.filesIngested || 0) - (a.counters?.filesIngested || 0)
        )[0];
        if (active && w) {
          watcherGitHash = w.gitHash || null;
          const hash = w.gitHash ? ` \u00b7 ${w.gitHash}` : '';
          const files = (w.counters?.filesIngested || 0).toLocaleString();
          const assets = (w.counters?.assetsIngested || 0).toLocaleString();
          const errors = w.counters?.errorsCount || 0;
          const lastIngestAgo = data.lastIngestAt ? Date.now() - new Date(data.lastIngestAt).getTime() : Infinity;
          const isIngesting = lastIngestAgo < 15000;
          if (isIngesting) {
            watcherDot.className = 'overview-dot dot-yellow';
            watcherDetail.textContent = `Ingesting...${hash} \u00b7 ${files} files, ${assets} assets so far`;
          } else if (errors > 0) {
            watcherDot.className = 'overview-dot dot-yellow';
            watcherDetail.textContent = `Active${hash} \u00b7 ${files} files, ${assets} assets \u00b7 ${errors} error(s)`;
          } else {
            watcherDot.className = 'overview-dot dot-green';
            watcherDetail.textContent = `Active${hash} \u00b7 ${files} files, ${assets} assets ingested`;
          }
          watcherAction.innerHTML = '';
        } else {
          watcherDot.className = 'overview-dot dot-red';
          watcherDetail.textContent = 'No watcher connected \u2014 file changes won\'t be indexed';
          watcherAction.innerHTML = '<button class="action-btn" onclick="overviewStartWatcher(this)">Start</button>';
        }
      } else {
        watcherDot.className = 'overview-dot dot-red';
        watcherDetail.textContent = 'Status unknown';
        watcherAction.innerHTML = '<button class="action-btn" onclick="overviewStartWatcher(this)">Start</button>';
      }

      // Version mismatch detection
      const mismatch = serviceGitHash && watcherGitHash
        && serviceGitHash !== 'unknown' && watcherGitHash !== 'unknown'
        && serviceGitHash !== watcherGitHash;
      if (mismatch) {
        versionAlert.classList.add('visible');
        document.getElementById('version-alert-hashes').textContent =
          `Service (${serviceGitHash}) \u00b7 Watcher (${watcherGitHash})`;
        const actionsEl = document.getElementById('version-alert-actions');
        actionsEl.innerHTML = `
          <button class="btn-primary" onclick="stopAndRestartWatcher(this)">Restart Watcher</button>
          <span class="version-alert-status" id="version-alert-status"></span>`;
      } else {
        versionAlert.classList.remove('visible');
      }

      // Zoekt status (reuse healthData from above — no extra fetch)
      if (healthData) {
        const zoekt = healthData.zoekt || {};
        if (zoekt.running || zoekt.available) {
          zoektDot.className = 'overview-dot dot-green';
          const shards = zoekt.shardCount != null ? `${zoekt.shardCount} shards` : 'running';
          const restarts = zoekt.restartAttempts > 0 ? ` \u00b7 ${zoekt.restartAttempts} restart(s)` : '';
          zoektDetail.textContent = shards + restarts;
          zoektAction.innerHTML = '<button class="action-btn action-btn-warn" onclick="overviewRestartZoekt(this)">Restart</button>';
        } else if (zoekt.configured === false || (!zoekt.running && !zoekt.available && !zoekt.shardCount)) {
          zoektDot.className = 'overview-dot dot-gray';
          zoektDetail.textContent = 'Not configured \u2014 install Go + Zoekt for grep search';
          zoektAction.innerHTML = '';
        } else {
          zoektDot.className = 'overview-dot dot-red';
          const detail = zoekt.restartAttempts >= 5
            ? 'Crashed (max restarts reached) \u2014 grep unavailable'
            : 'Not running \u2014 grep search unavailable';
          zoektDetail.textContent = detail;
          zoektAction.innerHTML = '<button class="action-btn" onclick="overviewRestartZoekt(this)">Restart</button>';
        }
      } else {
        zoektDot.className = 'overview-dot dot-gray';
        zoektDetail.textContent = 'Unknown';
        zoektAction.innerHTML = '';
      }
    }

    async function stopAndRestartWatcher(btn) {
      const status = document.getElementById('version-alert-status');
      btn.disabled = true;
      btn.textContent = 'Stopping watcher...';
      status.textContent = '';
      try {
        await fetch('/api/watcher/stop', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ workspace: WorkspaceContext.active })
        });
        status.textContent = 'Waiting for watcher to stop...';
        let stopped = false;
        for (let i = 0; i < 20; i++) {
          await new Promise(r => setTimeout(r, 1000));
          const sr = await WorkspaceContext.serviceFetch('/watcher-status');
          const sd = await sr.json();
          if (!sd.hasActiveWatcher) { stopped = true; break; }
        }
        if (!stopped) {
          status.textContent = 'Watcher did not stop in time. Try closing it manually.';
          btn.textContent = 'Restart Watcher';
          btn.disabled = false;
          return;
        }
        btn.textContent = 'Starting watcher...';
        status.textContent = '';
        const startResp = await fetch('/api/watcher/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ workspace: WorkspaceContext.active })
        });
        if (!startResp.ok) {
          const err = await startResp.json();
          status.textContent = err.error || 'Failed to start watcher';
          btn.textContent = 'Restart Watcher';
          btn.disabled = false;
          return;
        }
        status.textContent = 'Waiting for new watcher...';
        for (let i = 0; i < 30; i++) {
          await new Promise(r => setTimeout(r, 2000));
          const sr = await WorkspaceContext.serviceFetch('/watcher-status');
          const sd = await sr.json();
          if (sd.hasActiveWatcher) { loadAllWithOverview(); return; }
        }
        status.textContent = 'Watcher started but still reconciling. Refresh shortly.';
        btn.textContent = 'Restart Watcher';
        btn.disabled = false;
      } catch (err) {
        status.textContent = 'Error: ' + err.message;
        btn.textContent = 'Restart Watcher';
        btn.disabled = false;
      }
    }

    async function overviewStartWatcher(btn) {
      btn.disabled = true;
      btn.textContent = 'Starting...';
      try {
        const resp = await fetch('/api/watcher/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ workspace: WorkspaceContext.active })
        });
        if (!resp.ok) {
          const data = await resp.json();
          btn.textContent = data.error || 'Failed';
          setTimeout(() => { btn.textContent = 'Start'; btn.disabled = false; }, 5000);
          return;
        }
        btn.textContent = 'Started';
        let attempts = 0;
        const poll = setInterval(async () => {
          attempts++;
          try {
            const sr = await WorkspaceContext.serviceFetch('/watcher-status');
            const sd = await sr.json();
            if (sd.hasActiveWatcher) {
              clearInterval(poll);
              loadOverview();
              loadWatcher();
            }
          } catch {}
          if (attempts >= 30) {
            clearInterval(poll);
            btn.textContent = 'Start';
            btn.disabled = false;
          }
        }, 2000);
      } catch (err) {
        btn.textContent = 'Error';
        setTimeout(() => { btn.textContent = 'Start'; btn.disabled = false; }, 5000);
      }
    }

    async function overviewRestartZoekt(btn) {
      btn.disabled = true;
      btn.textContent = 'Restarting...';
      try {
        const resp = await WorkspaceContext.serviceFetch('/internal/restart-zoekt', { method: 'POST' });
        const data = await resp.json();
        if (resp.ok) {
          btn.textContent = 'Restarted';
          setTimeout(() => loadOverview(), 1000);
        } else {
          btn.textContent = data.error || 'Failed';
          if (data.hint) document.getElementById('ov-zoekt-detail').textContent = data.hint;
          setTimeout(() => { btn.textContent = 'Restart'; btn.disabled = false; }, 4000);
        }
      } catch (err) {
        btn.textContent = 'Error';
        setTimeout(() => { btn.textContent = 'Restart'; btn.disabled = false; }, 3000);
      }
    }

    async function overviewRestartService(btn) {
      if (!confirm('Restart the indexing service? The dashboard will reconnect automatically.')) return;
      btn.disabled = true;
      btn.textContent = 'Restarting...';
      try {
        await WorkspaceContext.serviceFetch('/internal/restart-service', { method: 'POST' });
      } catch {}
      document.getElementById('ov-service-dot').className = 'overview-dot dot-yellow';
      document.getElementById('ov-service-detail').textContent = 'Restarting...';
      let attempts = 0;
      const poll = setInterval(async () => {
        attempts++;
        try {
          const resp = await WorkspaceContext.serviceFetch('/health');
          if (resp.ok) {
            clearInterval(poll);
            loadAllWithOverview();
          }
        } catch {}
        if (attempts >= 30) {
          clearInterval(poll);
          document.getElementById('ov-service-dot').className = 'overview-dot dot-red';
          document.getElementById('ov-service-detail').textContent = 'Failed to restart \u2014 check logs';
          btn.textContent = 'Restart';
          btn.disabled = false;
        }
      }, 2000);
    }

    // --- Projects card (merged config + stats + freshness) ---

    async function loadConfig() {
      const el = document.getElementById('projects-table');
      try {
        const [configResp, statsResp, watcherResp] = await Promise.all([
          WorkspaceContext.serviceFetch('/internal/config'),
          WorkspaceContext.serviceFetch('/stats'),
          WorkspaceContext.serviceFetch('/watcher-status'),
        ]);
        const cfg = (await configResp.json()).config;
        const stats = await statsResp.json();
        const watcherData = await watcherResp.json();
        const projectStats = stats.projects || {};
        const freshness = {};
        for (const p of watcherData.projectFreshness || []) {
          freshness[p.project] = p;
        }

        let html = '<table><tr><th>Project</th><th>Language</th><th>Files</th><th>Types</th><th>Last Modified</th><th>Paths</th></tr>';
        for (const proj of cfg.projects || []) {
          const ps = projectStats[proj.name] || {};
          const fr = freshness[proj.name] || {};
          const files = ps.files || 0;
          const types = ps.types || 0;
          const age = fr.lastFileModified ? formatRelative(fr.lastFileModified) : '\u2014';
          const ageMs = fr.lastFileModified ? Date.now() - new Date(fr.lastFileModified).getTime() : Infinity;
          const ageCls = ageMs > 86400000 ? 'health-err' : ageMs > 3600000 ? 'health-warn' : 'health-ok';
          const pathList = (proj.paths || []).map(p => esc(p)).join('<br>');
          html += `<tr>
            <td><strong>${esc(proj.name)}</strong></td>
            <td>${esc(proj.language)}</td>
            <td class="mono">${files.toLocaleString()}</td>
            <td class="mono">${types.toLocaleString()}</td>
            <td class="${ageCls}">${age}</td>
            <td class="mono" style="font-size:11px">${pathList}</td>
          </tr>`;
        }
        html += '</table>';

        el.innerHTML = html;
        window._currentConfig = cfg;
      } catch (err) {
        el.innerHTML = `<span class="error">Failed to load: ${esc(err.message)}</span>`;
      }
    }

    function toggleConfigEdit() {
      const view = document.getElementById('config-view');
      const editor = document.getElementById('config-editor');
      const btn = document.getElementById('config-edit-btn');
      if (editor.style.display === 'none') {
        document.getElementById('config-textarea').value = JSON.stringify(window._currentConfig, null, 2);
        editor.style.display = 'block';
        view.style.display = 'none';
        btn.textContent = 'Cancel';
      } else {
        editor.style.display = 'none';
        view.style.display = 'block';
        btn.textContent = 'Edit';
        document.getElementById('config-save-status').textContent = '';
      }
    }

    async function saveConfig() {
      const statusEl = document.getElementById('config-save-status');
      const textarea = document.getElementById('config-textarea');
      let newConfig;
      try {
        newConfig = JSON.parse(textarea.value);
      } catch (e) {
        statusEl.textContent = 'Invalid JSON: ' + e.message;
        statusEl.style.color = '#f44747';
        return;
      }
      statusEl.textContent = 'Saving...';
      statusEl.style.color = '#808080';
      try {
        const resp = await WorkspaceContext.serviceFetch('/internal/config', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(newConfig)
        });
        const data = await resp.json();
        if (!resp.ok) {
          statusEl.textContent = data.error || 'Save failed';
          statusEl.style.color = '#f44747';
          return;
        }
        statusEl.textContent = 'Saved! Watcher picks up changes on next heartbeat (~15s).';
        statusEl.style.color = '#4ec9b0';
        toggleConfigEdit();
        loadConfig();
      } catch (err) {
        statusEl.textContent = 'Error: ' + err.message;
        statusEl.style.color = '#f44747';
      }
    }

    async function loadAllWithOverview() {
      if (!WorkspaceContext.active) {
        await WorkspaceContext.load();
      }
      if (!WorkspaceContext.active) return;
      await Promise.all([loadOverview(), loadHealth(), loadIndexStats(), loadWatcher(), loadConfig()]);
    }

    window.onWorkspaceChanged = () => loadAllWithOverview();

    // Wait for WorkspaceContext to load, then fetch data
    initDashboard('dashboard');
    WorkspaceContext.load().then(() => loadAllWithOverview());
    setInterval(loadAllWithOverview, 15000);
  </script>
</body>
</html>
